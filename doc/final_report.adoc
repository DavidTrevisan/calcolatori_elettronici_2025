= Calcolatori Elettronici 2025: Projects Report
:doctype: book
:toc:
:toc-title: Indice dei Contenuti
:toclevels: 3
:preface-title: Introduzione
:figure-caption: Figura
:listing-caption: Listato
:note-caption: Nota
:warning-caption: Avvertenza
David Trevisan

// Use the following template to have only the caption text when linking to image
// [#fig_mem_lat_bug2,reftext='{figure-caption} {counter:refnum}']

== Introduzione

Questo documento contiene il resoconto finale dei progetti di esame del corso di Calcolatori Elettronici 2025, tenuto dal prof. Mirko Loghi, Universitá degli Studi di Udine.

Dopo aver presentato alcune informazioni preliminari per la gestione della _code-base_ allegata, verranno descritti i passaggi effettuati ed i risultati ottenuti nell'analisi dei progetti oggetto di esame.

Per primo si studierá il componente `onescounter` nelle sue diverse versioni, con una breve analisi sulle modifiche più rilevanti del codice sorgente.
Si mostrerá l'utilizzo degli strumenti forniti per agevolare l'esecuzione delle simulazioni.
Verranno inoltre presentati i diagrammi relativi al dispositivo, ed alcune forme d'onda d'esempio per illustrarne il funzionamento.

Seguirá poi una simile analisi per il dispositivo `search_chr`.
Anche in questo caso verrá descritto il percorso effettuato per ottenere le diverse versioni.
Verrá spesa una piccola sezione per delle considerazioni sul modello di memoria utilizzato ed il suo ampliamento per funzionamento a latenza variabile.
Si concluderá quindi il capitolo con i diagrammi relativi al _device_ ed i risultati di simulazione RTL.

Dal terzo progetto, `multiplier_and_clz`, si inizierá invece a considerare anche il flusso di sintesi oltre al livello RT.
##TODO##

Per l'ultimo progetto verrá presentato il dispositivo `mcd`.
Si analizzerá la struttura del codice sorgente per dedurne il funzionamento.
Si presenteranno i relativi diagrammi ASM-Chart e del datapath estratti, per poi procedere alla descrizione dell'infrastruttura di test sviluppata.
Si utilizzerá quindi la stessa per eseguire delle simulazioni RTL.
##TODO##

{nbsp}

{nbsp}

{nbsp}

{nbsp}

{nbsp}

{nbsp}

{nbsp}

{nbsp}

{nbsp}

{nbsp}

Documento generato dalla revisione Git: {git-sha}

== Informazioni Preliminari

[#dir_struct]
=== Directory Structure

Ogni progetto assume la seguente struttura di cartelle:

[%unbreakable]
[source,ruby]
----
<prj_path>
│
├── assets
│ └── <prj_assets>
├── code
│ │
│ ├── <prj_srcs>.vhdl
│ │
│ ├── ...
│ │
│ └── <prj_tb>.vhdl
│
├── scripts
│ │
│ ├── runSim_ghdl
│ │
│ ├── ...
│ │
│ └── <synth>.tcl
│
├── *simul.rtl
│ └── ...
│
├── *simul.gate
│ └── ...
│
├── *synth
│ ├── libs
│ └── output
│
└── sources.vc
----

Le cartelle `simul.gate` e `simul.rtl` possono non essere presenti, mentre gli script potranno generarle come percorsi di lavoro per le relative fasi.

La cartella `code` contiene tutti i sorgenti necessari al funzionamento del dispositivo, ed i sorgenti necessari alla simulazione.

La cartella `assets` contiene eventuali file di utilizzo del dispositivo o del testbench;
Ad esempio i file di input agli stimoli del TB potranno trovarsi in `<prj_path>/assets/data.txt`, se lo stesso viene chiamato dal codice in simulazione.

La cartella `synth` contiene i dati relativi alla sintesi del dispositivo.
Questa cartella viene creata dagli script forniti.
Alternativamente bisogna crearla secondo i requisiti ##TODO##.

[#sources_file]
Il file `sources.vc` é una lista dei file sorgente che devono essere passati al tool di analisi.
Per compatibilitá con GHDL, che non fornisce l'opzione di utilizzare direttamente file-lists da parametri di _command line_, lo script fornito estrae i nomi e percorsi dei file in autonomia.

Il formato atteso per questo funzionamento é:

* un nome file per riga.
* fine riga: `line-feed` (`\n`).
* percorso del file relativo (plausibilemente sempre `code/file.vhdl`).
* l'ultimo file in lista contiene la top-entity da simulare (solitamente il `testbench`).
* new-line finale (riga vuota) in stile sorgente C.

=== Versione degli strumenti

Le considerazioni effettuate in questo documento derivano dall'utilizzo dei relativi strumenti nelle seguenti versioni:

* `GHDL 6.0.0-dev (b6.0.0.r58.g87396157e) - GNAT version 14.2.1`
* `GTKWave Analyzer v3.3.121`
* `Xcelium 20.09-s001`
* `Genus Synthesis Solution 19.14-s108_1`
* `Python 3.13.3`

Versioni anteriori potrebbero non essere correttamente supportate.

=== Scripts

Vengono presentati di seguito gli script che sono stati compilati come parte del _framework_ per l'esecuzione sistematica dei progetti inclusi.

Si riportano la descrizione del funzionamento e le eventuali dipendenze per gli script inclusi.

[#script_ghdl]
==== `runSim_ghdl`

Questo script é un _helper_ che colleziona alcune utilities per eseguire automaticamente:

* analisi ed elaborazione tramite GHDL
* simulazione tramite GHDL
* apertura del 'wave-file' generato tramite GTKWave

Per funzionare, lo script necessita delle seguenti dipendenze:

* GHDL (v5+)
* GTKWave
* Bash built-ins (POSIX):
** `readlink`, `realpath`
** `dirname`, `basename`
** `grep`
** `tail`
** `eval`
** `mkdir`
** `pushd`, `popd`

Inoltre la struttura directory del progetto, passato come primo argomento quando si invoca lo script, si assume rispecchi quella definita nella sezione <<#dir_struct>>.

Per utilizzare lo script, la linea di comando tipica segue la forma:

[#runSim_ghdl_generic]
[source,bash]
----
$ scripts/runSim_ghdl projects/<prj_name> [(Optional) GENERIC_OVERRIDE=Value]
----

Dove il primo argomento é obbligatorio e corrisponde al percorso del progetto che si vuole simulare, mentre i seguenti argomenti saranno interpretati come 'generic overrides' e passati alla linea di comando con il prefisso `-g`, come accettato da GHDL.
Lo script estrae i file da analizzare ed elaborare da una lista `sources.vc` nel root-path del progetto, con un file per linea indicato come percorso relativo.
Si veda il paragrafo <<sources_file, sources.vc>> per altri dettagli.

[#script_check_mcd]
==== `parse_and_check_mcd.py`

Durante lo sviluppo dell'infrastruttura di test per il progetto <<project_mcd, Maximum Common Divisor (MCD)>>, é stato preparato questo script per automatizzare il controllo dei report generati.

Per funzionare il sistema deve rendere disponibile all'ambiente di esecuzione:

* python3
** libreria `re`
** libreria `math`
** libreria `sys`

Una normale installazione di python dovrebbe includere automaticamente le dipendenze elencate.

L'utilizzo dello script da linea di comando é il seguente:

[#check_mcd_usage]
[source,bash]
----
$ scripts/parse_and_check_mcd.py
Usage: scripts/parse_and_check_mcd.py <input_file>
----

Dove `<input_file>` é uno dei report indicati nella <<mcd_rtl_reports,relativa sezione>>.

== Progetti

include::onescounter.adoc[leveloffset=2]

<<<
include::search_chr.adoc[leveloffset=2]

<<<
include::multiplier_and_clz.adoc[leveloffset=2]

<<<
include::mcd.adoc[leveloffset=2]
