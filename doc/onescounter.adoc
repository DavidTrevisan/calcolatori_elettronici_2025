= Ones Counter

Il dispositivo `onescounter` viene presentato con le seguenti modifiche:

. Versione 'Moore'.
. Versione 'Mealy'.
** Entrambe le versioni sono descritte in `ctrlunit.vhdl` in due architetture separate.
. Selezione dell'architettura della CTRL Unit tramite _generic_.
. Aggiunto segnale `DEBUG` che sovrascrive il registro `ONES` con il valore posto all'ingresso `X`.

[NOTE]
====
* L'operazione é realizzabile e valida solo quando `READY = 1`.
* La modifica con il segnale `DEBUG` é stata effettuata in solo stile 'mealy'.
====

Il dispositivo viene consegnato con un testbench contenente le seguenti modifiche:

. Terminazione _graceful_ della simulazione al set del segnale `done`.
. Istanza simultanea di entrambe le versioni `moore` e `mealy` del DUT, input condivisi.
. Aggiunti `assert` per monitorare continuamente la corrispondenza tra gli output delle due versioni del dispositivo.
. Aggiunta la funzione `t2s_ns` per formattare i tempi in ns quando stampati da report.

[#script_onescounter]
Per analizzare ed elaborare il design ed eseguirne la simulazione é stato creato uno script bash, che viene fornito, ed é utilizzabile come segue:

[source,bash]
----
$ scripts/runSim_ghdl projects/01_onescounter
----

[NOTE]
====
Si verifichi che le dipendenze necessarie per eseguire lo script siano soddisfatte, come da sezione <<#script_ghdl>>.
====

Lo script richiede almeno un argomento, il path del progetto da simulare, ed assume la struttura directory come descritta nella <<#dir_struct, sezione dedicata>>.

Le operazioni eseguite dallo script sono le seguenti:

[source,bash]
----
# Sposta la $PWD nel percorso indicato del progetto, sottocartella `simul.rtl`
pushd <prj_path>/01_onescounter/simul.rtl
# Analisi GHDL per tutti i file estratti da sources.vc
ghdl -a -v --std=93c <prj_path>/01_onescounter/code/reg8.vhdl \
                    <prj_path>/01_onescounter/code/zerodetect.vhdl \
                    <prj_path>/01_onescounter/code/rshift.vhdl \
                    <prj_path>/01_onescounter/code/mux2x8.vhdl \
                    <prj_path>/01_onescounter/code/mux4x8.vhdl \
                    <prj_path>/01_onescounter/code/adder.vhdl \
                    <prj_path>/01_onescounter/code/datapath.vhdl \
                    <prj_path>/01_onescounter/code/ctrlunit.vhdl \
                    <prj_path>/01_onescounter/code/onescounter_pkg.vhdl \
                    <prj_path>/01_onescounter/code/onescounter.vhdl \
                    <prj_path>/01_onescounter/code/TB.vhdl
# Elaborazione
ghdl -e -v --std=93c tb
# Simulazione, salva wave-file in formato ghw
ghdl -r -v --std=93c --time-resolution=ns tb --wave=onescounter.ghw
# Invoca `gtkwave` per visualizzare il wave-file
gtkwave onescounter.ghw
# Al termine, ritorna alla directory iniziale
popd
----

Lo script estrae il path assoluto per ognuno dei file sorgente, per cui `<prj_path>` assumerá il valore dipendente dal percorso del sistema.

== Analisi dei File Sorgente

Il file `sources.vc` contiene la lista dei sorgenti utilizzati, che vengono di seguito elencati e brevemente descritti:

[table_onescounter_sources,subs="attributes+"]
[cols="25%,75%",options="header"]
|===
| File | Description

| `reg8.vhdl`
| Descrizione di un registro di larghezza 8 bit da usarsi nella rappresentazione strutturale.

| `zerodetect.vhdl`
| Descrizione di un comparatore con `0` di larghezza 8 bit da usarsi nella rappresentazione strutturale.

| `rshift.vhdl`
| Descrizione di un right-shift-register di larghezza 8 bit da usarsi nella rappresentazione strutturale.

| `mux2x8.vhdl`
| Descrizione di un multiplexer 2 ingressi da 8 bit ciascuno, da usarsi nella rappresentazione strutturale.

| `mux4x8.vhdl`
| Descrizione di un multiplexer 4 ingressi da 8 bit ciascuno, da usarsi nella rappresentazione strutturale.

| `adder.vhdl`
| Descrizione di un semplice adder (senza carry out) da 8 bit da usarsi nella rappresentazione strutturale

| `datapath.vhdl`
| Descrizione del Datapath del dispositivo.
Contiene la versione comportamentale (architecture `s`) e strutturale (architecture `struct`).

| `ctrlunit.vhdl`
| Descrizione comportamentale della rete di controllo del dispositivo.
Contiene due architetture corrispondenti agli ASM chart versione `moore` e versione `mealy`.

| `onescounter_pkg.vhdl`
| Package che contiene la descrizione del componente `onescounter`.

| `onescounter.vhdl`
| Descrizione strutturale del dispositivo (top level).

| `TB.vhdl`
| Testbench che istanzia il DUT ed i suoi stimoli.

|===


Vengono presentati di seguito alcuni snippets rilevanti per il funzionamento dei sorgenti.

=== onescounter.vhdl
Al dispositivo é stato aggiunto un _generic_ di tipo testuale (_string_) per indicare quale architettura istanziare.

[source, vhdl]
====
    entity onescounter is
        generic
        (
            CTRL_TYPE	: string := "moore"
        );
        ...
====

Per mantenere la compatibilitá con VHDL-1993, sono stati utilizzati due costrutti `if ... generate ... end generate` per istanziare l'architettura desiderata.

[source, vhdl]
====
    gen_mealy : if (CTRL_TYPE = "mealy") generate
        CTRL_mealy : entity work.ctrlunit(mealy)
        port map
        (
            CLK         => CLK,
            rst_n       => rst_n,
            DATAIN      => DATAIN,
            CALC        => CALC,
            DEBUG       => DEBUG,
            READY       => READY,
            OK          => OK,
            loadA       => loadA,
            selA        => selA,
            loadONES    => loadONES,
            selONES     => selONES,
            LSB_A       => LSB_A,
            zA          => zA
        );
    end generate;

    gen_moore : if (CTRL_TYPE /= "mealy") generate
        CTRL_moore : entity work.ctrlunit(moore)
        port map
        (
            CLK         => CLK,
            rst_n       => rst_n,
            DATAIN      => DATAIN,
            CALC        => CALC,
            DEBUG       => DEBUG,
            READY       => READY,
            OK          => OK,
            loadA       => loadA,
            selA        => selA,
            loadONES    => loadONES,
            selONES     => selONES,
            LSB_A       => LSB_A,
            zA          => zA
        );
    end generate;
====

[#source_dp]
=== datapath.vhdl

Per il registro `ONES` sono stati aggiunti diversi ingressi selezionabili rispetto alla versione originale, che sono riassunti nello spezzone:

[source, vhdl]
====
    -- MUX for ONES
    ONES_in <= (others => '0')                          when selONES = "00" else
                X                                       when selONES = "10" else
                (ONES_in'LEFT downto 1 => '0') & '1'    when selONES = "11" else
                adder1;
====

Considerando che ad ogni fronte di salita di `CLK` il segnale `ONES_in` viene registrato da `ONES`, la mappa di selezione del multiplexer al suo ingresso é:

[table_onesSel,subs="attributes+"]
[cols="^2,8",options="header"]
|===
| selOnes
| Descrizione

| `"00"`
| Seleziona il valore `'0000_0000'`.

| `"01"`
| Seleziona il segnale in uscita dal sommatore `ONES + 1`.

| `"10"`
| Seleziona il valore `X`.

| `"11"`
| Seleziona il valore `'0000_0001'`.

|===

=== TB.vhdl

Il testbench istanzia entrambe le architetture del dispositivo `onescounter` simultaneamente, raddoppiando solo i segnali di uscita e mantenendone invece i segnali di input unici.

[source, vhdl]
====
    DUT_moore : onescounter
    generic map
    (
        CTRL_TYPE => "moore"
    )
    port map
    (
        ...
    );

    DUT_mealy : onescounter
    generic map
    (
        CTRL_TYPE => "mealy"
    )
    port map
        ...
====

Sono stati quindi aggiunti degli `assert` per tenere monitorati i segnali di output che, in determinati momenti, sono da assumersi identici tra le due versioni.

[source, vhdl]
====
    assert not ((rst_n = '1') and
                (OK_mealy = '1' or OK_moore = '1') and
                (OUTP_mealy /= OUTP_moore))
        report "ERROR: OUTP output differs between DUTs when OK signal is set. Time: " & t2s_ns(now)
        severity error;

    assert READY_mealy = READY_moore
        report "ERROR: READY output differs between DUTs. Time: " & t2s_ns(now)
        severity error;

    assert OK_mealy = OK_moore
        report "ERROR: OK output differs between DUTs. Time: " & t2s_ns(now)
        severity error;
====

Considerato che GHDL utilizza il _femtosecondo_ quale unitá di tempo, é stata introdotta la funzione `t2s_ns` (_time to string ns_) per stampare coerentemente l'eventuale tempo di simulazione di un `assert` fallito.

[source, vhdl]
====
    function t2s_ns(t : time) return string is
        variable nano : integer := integer(t / 1 ns);
    begin
        return integer'image(nano) & " ns";
    end function;
====

Per terminare in maniera _graceful_ la simulazione, é stato rimosso l' `assert` di interruzione alla fine degli stimoli di test.

La generazione del clock é invece stata modificata come segue per fermarsi al set del segnale `done`:

[source, vhdl]
====
    clk_process : process
    begin
        if (done = 1) then
            wait;
        else
            if CLK = '0' then
                CLK <= '1';
                wait for CLK_SEMIPERIOD1;
            else
                CLK <= '0';
                wait for CLK_SEMIPERIOD0;
                count     <= std_logic_vector(unsigned(count) + 1);
                int_count <= int_count + 1;
            end if;
        end if;
    end process clk_process;
====

In assenza di costrutti errati che mettano indefinitamente in stallo la simulazione, GHDL terminerá la sua esecuzione quando tutti gli eventi si fermeranno a seguito del set del segnale `done`.

.Asset data.txt
Il testbench utilizza un file esterno da cui leggere i dati da utilizzare per gli stimoli del Device Under Test.

Il file `assets/data.txt` é un file di testo ASCII contentente stringhe testuali da interpretarsi come valori binari.

Ogni iterazione di lettura del file si aspetta quattro elementi, uno per riga, nel seguente ordine:

. Una stringa da 8 bit per l'ingresso `X`
. Un singolo bit per l'ingresso di `DEBUG`
. Un singolo bit per l'ingresso `DATAIN`
. Un singolo bit per l'ingresso `CALC`

Al termine di questo set di stimoli, una riga vuota viene scartata e utilizzata per separare i gruppi di segnali.
Per terminare il file e, quindi, il test occorre aggiungere una seconda riga vuota che verrá decodificata dal processo `read_file_process` quale trigger per la terminazione della simulazione.


<<<
== ASM Chart

Per la versione 'moore', il dispositivo `onescounter` rispecchia il seguente ASM chart:

// :page-layout: landscape
image::images/ASM-onescounter_moore.drawio.svg[align=center,pdfwidth=100%]

// :page-layout: portrait

NOTE: La funzionalitá del segnale `DEBUG` é stata comunque implementata in stile 'mealy'.

Come esplicitato nella sezione del diagramma relativo al datapath, al registro `ONES` é stato posto in ingresso un `mux` a 4 ingressi come spiegato nella sezione <<source_dp>>.

<<<

Il diagramma relativo alla versione 'mealy' é invece il seguente:

image::images/ASM-onescounter_mealy.drawio.svg[align=center,pdfwidth=100%]

Mentre il datapath é rimasto inalterato, l'utilizzo delle _conditional output box_ ha permesso di ridurre il numero degli stati, integrando la funzionalitá dello stato `INC` all'interno dello stato `SHIFT`.

La funzionalitá del segnale `DEBUG` corrisponde a quella della versione precedente.

Si nota come nella versione Mealy l'ottimizzazione risultante dalla rimozione dello stato `INC` a favore dell'utilizzo delle conditional output boxes, stimoli un incremento immediato del registro `ONES` rispetto alla versione Moore.
Questa cosa verrá infatti osservata in fase di simulazione e verifica.

La decisione di fornire un testbench unico per stimolare simultaneamente le diverse architetture, viene avvallata dai seguenti motivi:

* Il datapath resta identico.
* Le specifiche sugli input/output restano identiche.
* La funzionalitá e le tempestiche del device rispetto ai suoi ingressi ed uscite non cambiano.

Si deduce quindi che, pur assumendo delle possibili variazioni di tempistiche interne alla macchina a stati, le due architetture si debbano comportare in maniera equivalente quando osservate sulle loro porte.

== Risultati

Seguendo le fasi indicate nel paragrafo relativo allo <<#script_onescounter, script>>, si raccolgono le relative considerazioni in questa sezione.

.Analisi ed elaborazione
Non sono state incontrate particolari criticitá nella fase di analisi ed elaborazione dei listati.

I sorgenti sono stati costruiti in modo da non causare warning od errori in questa fase, assumendo l'utilizzo dello standard VHDL-1993 con regole di binding aggiornate (_GHDL option_ `--std=93c` - default).

.Simulazione

L'esecuzione del simulatore cosí generato da GHDL riporta alcuni warning, ed il completamento dei test secondo quanto impostato nel file `assets/data.txt`.

[source, bash]
====
    ghdl -r -v --std=93c  --time-resolution=ns  tb --wave=onescounter.ghw

    Linking in memory
    ../../src/ieee/v93/numeric_std-body.vhdl:1710:7:@0ms:(assertion warning): NUMERIC_STD."=": metavalue detected, returning FALSE
    ../../src/ieee/v93/numeric_std-body.vhdl:1710:7:@0ms:(assertion warning): NUMERIC_STD."=": metavalue detected, returning FALSE
    ../../src/ieee/v93/numeric_std-body.vhdl:1710:7:@145ns:(assertion warning): NUMERIC_STD."=": metavalue detected, returning FALSE
    ../../src/ieee/v93/numeric_std-body.vhdl:1710:7:@145ns:(assertion warning): NUMERIC_STD."=": metavalue detected, returning FALSE
    END simulation - cycle counter is 59
====

I primi due warning si riferiscono alla presenza di segnali _"uninitialized"_ all'inizio della simulazione (0ms).
Questi segnali sono gli input `X` e `DEBUG` del device.
Inoltre, a tempo 0, il segnale `rst_n` indica che cié un reset in corso sul dispositivo.

I secondi warning si riferiscono allo stesso problema, ma al primo istante utile (fronte di clock) all'uscita dal reset, ossia a tempo 145ns come visibile nell'immagine.

image::images/onescounter_Xprop.png[]

In questo caso, essendo iniziato il funzionamento del dispositivo, il segnale `X` non ancora inizializzato viene ora acquisito nel registro `A` ed il suo bit inferiore salvato in `LSB_A`.
Registrando valori non inizializzati si attiva quindi il warning ulteriormente.

Poiché gli stessi input vengono assegnati dal test sulla base di quanto letto nel file di `assets/data.txt`, che avviene solo all'uscita dal reset e con device pronto (`READY`), si assume che entrambi i gruppi di warning siano "innoqui".
Inoltre il dispositivo si configura correttamente anche nel caso della propagazione delle `'U'` ai registri.

Per eliminare questi warning occorrerebbe modificare il file di stimolo e la lettura relativa al fine di forzare l'inizializzazione dei segnali relativi all'istante 0, ma per le considerazioni precedenti si é scelto di non modificarne il comportamento rispetto all'originale.

.Verifica del funzionamento
Il dispositivo é stato quindi simulato e verificato nel suo funzionamento attraverso test diretti ed ispezione manuale delle forme d'onda, e la corrispondenza del funzionamento in maniera automatica tramite gli assert sugli output.

