= Other Device: Maximum Common Divisor (MCD)

Questa sezione analizza il dispositivo `MCD` come quarto componente nello studio del _design flow_ dei dispositivi e calcolatori elettronici.
Verranno analizzati il codice originale per spiegarne il funzionamento e fornire una rappresentazione grafica della sua Control Unit e Datapath.

Verranno poi spiegate le informazioni salienti sullo sviluppo dell'algoritmo di test e del testbench per valutare e verificare il dispositivo `MCD` a livello _RT_ e _gate-level_.

Si concluderá infine il capitolo con valutazioni sulla sintesi del device ed i risultati ottenuti con la libreria tecnologica scelta.

== Code analysis

Il dispositivo é progettato per calcolare il _massimo comun divisore_ tra due numeri (operandi) forniti in ingresso.

Si ricorda che:

> il massimo comun divisore di due numeri interi, entrambi non nulli, corrisponde al numero naturale più grande per il quale entrambi possono essere divisi esattamente

Dall'anilisi delle porte di _top-level_ del componente `mcd`, si ottiene il seguente prospetto:


[table_mcd_IOports,subs="attributes+"]
[cols="^2m,^2,6",options="header"]
|===

|Signal
|Direction
|Description

|abort
|IN
|

|operand1
|IN
|Primo operando per la ricerca del MCD

|operand2
|IN
|Secondo operando per la ricerca del MCD

|res
|OUT
|Risultato dell'elaborazione, MCD di `operand1` e `operand2`

|start
|IN
|Segnale di `valid` per gli operandi in ingresso.
Richiede una nuova computazione del MCD.

|ready
|OUT
|Segnale di `valid` di `res`.
Indica che il risultato in uscita al dispositivo puó essere valutato.

|===

[.center,svgbob-mcd_ports]
[svgbob]
----
                           +----------------+
   operand1[OPSIZE] ------>|                |
   operand2[OPSIZE] ------>|                |----> res [OPSIZE]
                           |                |
                           |      mcd       |
              start ------>|                |----> ready
              abort ------>|                |
                           |                |
                           +----------------+
----

Il file `mcd.vhdl` contiene una rappresentazione strutturale del dispositivo, istanziando semplicemente control unit e datapath, insieme alla logica di collegamento interna ed alle porte.
Il dispositivo presenta un parametro `generic OPSIZE` di tipo intero, utilizzato per definire la larghezza in bit degli operandi e del risultato.

Il file `mcd_ctrl.vhdl` rappresenta la control unit del dispositivo in maniera comportamentale, implementando una semplice FSM (`ns_process`) per gestire le operazioni ed i segnali di controllo.
Lo stile utilizzato esplicita i segnali di load dei registri presenti nel datapath, ed i selettori dei multiplexer utilizzati attraverso statement concorrenti in maniera coerente con i dispositivi fin'ora analizzati.
Oltre la transizione degli stati, é visibile un _override_ ogniqualvolta il segnale `abort` viene settato.
Questo termina le eventuali operazioni in corso e riporta la CTRL-Unit allo stato `S_INIT`.
Si veda la rappresentazione ASM-chart in <<fig_mcd_ctrl>>.

Il file `mcd_dp.vhdl` implementa quindi il datapath in maniera gerarchica, istanziando il dispositivo `divider` al suo interno.
Come visibile in <<fig_mcd_dp>>, nel datapath vengono istanziati tre registri (`R_A`, `R_B`, `R_res`), due comparatori, un sommatore ed un componente che effettua la divisione.
I registri `R_A` ed `R_B` servono principalmente per trattenere gli operandi nelle fasi di elaborazione, mentre `R_res` salva il risultato dell'operazione.
Il sommatore, più propriamente un _sottrattore_, esplicita l'operazione di confronto `A >= B` attraverso le seguenti operazioni:

. Estende entrambi gli operandi sul MSB, aggiungendo uno `'0'` quale **MSB** (_Most Significant Bit_).
. Sottrae `R_B` da `R_A` (somma con complemento a due) interpretandoli senza segno.
.. `R_A + (~R_B + 1)`
. Il *MSB* del risultato indica se é un valore **non negativo**:
.. `MSB = 0` il risultato é nullo o positivo => `R_A >= R_B`
.. `MSB = 1` il risultato é negativo => `R_A < R_B`

Per il divisore si utilizza solo il segnale del _resto_ (`div1_remainder`) mentre il quoziente viene ignorato.

=== Analisi dell'algoritmo

Giudicando dalla transizione degli stati e dalle risorse istanziate, si deduce che il dispositivo implementi link:https://it.wikipedia.org/wiki/Algoritmo_di_Euclide[l'algoritmo di Euclide] per trovare il massimo comun divisore tra due numeri interi.

La sequenza delle operazioni del dispositivo `mcd` é:

. `S_INIT`
.. Salva `operand1 => R_A`.
.. Salva `operand2 => R_B`.
. `S_SUBTR`
.. Se `R_A >= R_B` inizia una divisione (`div1_start`).
.. Altrimenti scambia gli operandi (usando `R_res` come registro temporaneo) ed effettua la divisione.
. `S_MOD_START` - `S_MOD_WAIT`
.. Divide `R_A / R_B` in attesa del resto (`div1_remainder`).
.. Quando `divider` ha completato, salva i nuovi valori nei registri:
... `R_B <= R_A mod R_B` (il resto).
... `R_A <= R_B`.
.. Reitera l'operazione di divisione.
... Termina quando uno dei due registri diventa zero.
... Restituisce il valore non-nullo in `R_res`

L'algoritmo di Euclide corrisponde a questo comportamento, come verificabile dal seguente spezzone di codice python che lo descrive:

[source, python]
----
def mcd(a, b):
    while b != 0:
        t = b
        b = a % b
        a = t

    return a
----

Si assume che il primo operatore sia maggiore o uguale al secondo, cosa che viene infatti verificata dal dispositivo.

Un'ulteriore accortezza é implementata in `mcd` nel caso in cui uno od entrambi gli operandi in ingresso siano uguali a zero.
In questo caso l'algoritmo non é valido, quindi il dispositivo ritorna semplicemente in `S_IDLE` con zero quale risultato in uscita.

==== Divider

Il divisore utilizzato nell'implementazione di `mcd` non é parte delle stesse analisi sul funzionamento e sulle risorse.
Tuttavia si considerano queste caratteristiche salienti a riguardo:

. Divisore multi-ciclo di interi
. Larghezza parametrica degli operandi e del risultato
. Algoritmo usato: link:https://en.wikipedia.org/wiki/Division_algorithm#Restoring_division[Restoring Division]
.. Per ogni bit del dividendo originale (gli operandi vengono raddoppiati in larghezza):
... Shift a sinistra del resto ed il prossimo bit del dividendo.
... Sottrae il divisore dal resto.
... Se la sottrazione é `>= 0`, imposta il bit del quoziente a 1.
... Altrimenti _ripristina_ il resto ed imposta il bit del quoziente a 0.
.. Al termine del loop si ottiene il resto ed il quoziente.

=== ASM Chart

La rappresentazione della CTRL-Unit del dispositivo `mcd` é visibile nel seguente diagramma:

.`mcd` ASM-Chart CTRL-Unit
[#fig_mcd_ctrl,reftext='{figure-caption} {counter:refnum}']
image::images/ASM-mcd_ctrl.drawio.svg[]

Dove si é apposto un flusso fuori dal normale controllo della FSM per indicare il comportamento del segnale `abort` quale _override_ del normale funzionamento.

Le risorse visibili nel datapath sono invece rappresentate nella seguente immagine:

.`mcd` Risorse Datapath
[#fig_mcd_dp,reftext='{figure-caption} {counter:refnum}']
image::images/ASM-mcd_dp.drawio.svg[]

Si é rappresentato il componente `divider` come un blocco gerarchico di cui si considera solo il comportamento alle porte di input e di output.
Il divisore appare come un dispositivo multi-ciclo, che inizia un'operazione al set del segnale `start` e segnala la validitá dei suoi output (quoziente e resto) tramite il segnale `ready`.
Risulta presente un segnale di `abort` per terminare prematuramente una divisione in corso.
Anche per il divisore é presente il `generic OPSIZE` corrispondente a quello del dispositivo `mcd` che controlla la larghezza in bit degli operandi e del risultato.

== Tester e Testbench

Per osservare e verificare il funzionamento del dispositivo sono stati sviluppati un testbench ed un tester.
L'architettura di test segue l'impostazione vista in nella sezione <<Multiplier and Count Leading Zeroes>>, con dei minimi aggiustamenti per il funzionamento di `mcd`.

// see https://ivanceras.github.io/svgbob-editor/

[.custom-style,svgbob-mcd_tb_arch]
[svgbob]
----
.------------------------------------------------------------------.
|                                                                  |
|                        +--------+                                |
|                        | rstgen |                                |
|                        +----+---+                                |
|                             |                                    |
|              +--------------+--------------+                     |
|              |                             |                     |
|              v                             v                     |
|        +----------+                   +-----------+              |
|        |          |                   |           |              |
|        |          | abort ----------->|           |              |
|        |          | start ----------->|           |              |
|        |          |                   |           |              |
|        |          | operand1 -------->|           |              |
|        |  tester  | operand2 -------->|    mcd    |              |
|        |          |                   |           |              |
|        |    {tg}  | <------------ res |   {dut}   |              |
|        |          | <---------- ready |           |              |
|        |          |                   |           |              |
|        |          | finished ---+     |           |              |
|        +----------+             |     +-----------+              |
|          ^                      |            ^                   |
|          |                      v            |                   |
|          |   +-------+       +----------+    |                   |
|          |   |  clk  |       |  finish  |    |                   |
|          |   |  gen  |<------+   proc   |    |                   |
|          |   +---+---+       +----------+    |                   |
|          |       |                           |                   |
|          +-------+---------------------------+                   |
|                                                      {tb}        |
|                                                      testbench   |
'------------------------------------------------------------------'

# Legend:
tb = {
    fill: papayawhip;
}
tg = {
    fill: lightblue;
}
dut = {
    fill: lightyellow;
}
----

== Simulations, Synthesis and Evaluations
=== RTL Simulations
=== Stdcells synthesis
=== Gate-level Simulations
=== Other evaluations
