Buongiorno Professore,

come le avevo ancitipato ho trovato degli impedimenti nel procedere con la gate-level simulation giá con il dispositivo del terzo progetto (`device` - multiplier and clz).
Sto comunque cercando di risolvere da solo, ma le scrivo lo stesso per metterla al corrente, visti il tempo giá impiegato.

Secondo la mia analisi questa problematica si presenta con l'utilizzo dei componenti `SDFFR_X*` o `DFFR_X*` della libreria `stdcells.v`/`stdcells.lib`, ossia nel file post syntesis map o syntesis opt, con o senza utilizzo di flip flop di scan chain.

Effettuando la simulazione gate-level sul file di sintesi (per esempio `device.syn_opt.v` che allego), il simulatore ritorna il seguente errore:

```
xmelab: *E,MXINDR: VHDL port of mode IN, :testbench:DUT<local>rst_n (./device_pkg_NBITS32.vhdl: line 9), is connected below to a Verilog port, :testbench:DUT.rst_n (../synth/output/device.syn_opt.v: line 13), with drivers.
```

In pratica ho trovato dei modi per aggirare l'errore, che sembra sorgere dalla natura mixed-language VHDL-Verilog del nostro framework di test, sia implementando un testbench direttamente in Verilog od un wrapper per `device`, sempre in linguaggio Verilog.
Tuttavia il risultato della simulazione é comunque insoddisfacente e credo che sorga dal seguente comportamento.

Il messaggio di errore segnala la presenza di driver in conflitto sulla porta di ingresso `rst_n`, ma ho constatato che il segnale é connesso solamente alle porte di reset (`.RN`) dei registri come ci si aspetterebbe.
Analizzando le forme d'onda ho trovato che il segnale di si trova comunque in conflitto (`x`) proprio durante la fase di reset.

Per isolare la problematica ho ridotto il DUT al seguente:

```
module device(CLK, rst_n, start, op, A, B, done, RES);
  input CLK, rst_n, start, op;
  input [31:0] A, B;
  output done;
  output [63:0] RES;
  wire dummy_n;
  DFFR_X1 \R_res_reg[54] (.RN (rst_n), .CK (CLK), .D (start), .Q
       (done), .QN (dummy_n));
endmodule
```

Allego l'immagine con le forme d'onda dove si vede che `rst_n` non viene correttamente pilotato a `0` logico nella fase di reset. Successivamente il comportamento appare corretto, ma nel caso del device completo la mancanza di reset non permette a quasi nessun registro di inizializzarsi correttamente, facendo fallire l'intero dispositivo gate-level.

Questa simulazione é effettuata con un wrapper verilog per aggirare l'errore, che allego, ma lo stesso risultato l'ho riscontrato con il testbench completamente in verilog, ed anche con l'utilizzo dei flip flop di scan `SDFFR_X1`.

Al momento sto rianalizzando tutti gli script ed il flusso di sintesi e di simulazione gate-level, ma non trovo difformitá particolari rispetto alle instruzioni in aula o da slide. Ho constatato questo comportamento sia con l'utilizzo della netlist verilog `stdcells.v` mentre con l'inclusione delle librerie vital vhdl non sembra accadere.
Assumendo che non ci siano errori nelle librerie stesse, sto cercando la causa nel flusso di operazioni, ma visto il lungo tempo impiegato la volevo intanto mettere al corrente.

Se desidera visualizzare il lavoro, ancora in corso, dovrebbe poter visualizzare tutto al percorso `/home/david.trevisan/03_multiplier_and_clz` del server eda-27267.
Sono comunque a disposizione per qualsiasi chiarimento.

-----------------------------------------------------------

Buonasera Professore,

come le anticipavo l'altro giorno, non riesco a procedere correttamente con le simulazioni gate-level per il dispositivo `device` (multiplier and clz).
Ho nuovamente provato a risolvere da solo per evitar di importunarla, ma non trovo delle soluzioni "pulite".

Dovrebbe poter visualizzare tutto il lavoro in corso al path `/home/david.trevisan/03_multiplier_and_clz` del server eda-27267.
Ho fatto degli script che sono descritti nel documento di progetto, tuttavia per quanto riguarda questa problematica i passaggi di sintesi e simulazione gate-level sono sostanzialmente identici alle slide, con la differenza di utilizzo della libreria `stdcells.lib` e `stdcells.v`.

La signature dell'errore di xcelium é la seguente:

```
xmelab: *E,MXINDR: VHDL port of mode IN, :testbench:DUT<local>rst_n (./device_pkg_NBITS32.vhdl: line 9), is connected below to a Verilog port, :testbench:DUT.rst_n (../synth/output/device.syn_opt.v: line 13), with drivers.
```

La mia interpretazione é la seguente:

L'intero code-base é in VHDL, escluso il file di sintesi in Verilog che presenta l'aliasing della porta `rst_n` nell'intestazione:

```
$ head -n 14 synth/output/device.syn_opt.v

// Generated by Cadence Genus(TM) Synthesis Solution 19.14-s108_1
// Generated on: Jul  3 2025 21:54:57 CEST (Jul  3 2025 19:54:57 UTC)

// Verification Directory fv/device_NBITS32

module device(CLK, rst_n, start, op, A, B, done, RES, TST_SH_EN, TST,
     TST_SCAN_IN, TST_SCAN_OUT);
  input CLK, rst_n, start, op, TST_SH_EN, TST, TST_SCAN_IN;
  input [31:0] A, B;
  output done, TST_SCAN_OUT;
  output [63:0] RES;
  wire CLK, rst_n, start, op, TST_SH_EN, TST, TST_SCAN_IN;
  wire [31:0] A, B;
```

come si vede nella prima riga dopo l'ultima definizione degli `output`. Pur essendo codice verilog legale (anche nelle slide si vede la stesso comportamento), direi che l'istanza di questo componente da ambiente VHDL sia vincolato a non poter essere collegato a nessun driver interno.

Analizzando il file Verilog post-sintesi, non mi sembra che ci siano driver espliciti nel top del modulo, ed il segnale `rst_n` sembra correttamente collegato ai soli reset dei registri, tuttavia l'errore persiste al comando `xmelab` del testbench.

Questo accade solamente con i file post "synthesis mapping" e "optimization" (`syn_map` e `syn_opt`), mentre la versione ottenuta tramite `syn_generic` si comporta come da aspettative.

Le versioni sintetizzate istanziano i flip-flop `SDFFR_*/SDFFRS_*` collegati al segnale `rst_n`.

Inserendo manualmente un componente tra questi (per esempio: `  SDFFR_X1 \fake (.RN (rst_n), .CK (CLK), .D (n_2408), .SI (n_2408), .SE (1'b0), .Q (dummy_wire_00), .QN (dummy_wire_01));`) nel verilog generato da `syn_generic`, ottengo peró lo stesso errore.

Non ho approfondito più di tanto nel file di libreria `stdcells.v`, ma ho cercato dei modi per aggirare il problema (wrapper in verilog, testbench in verilog...), ma in questi casi la simulazione termina senza effettuare alcun test (```xcelium> # Run simulation
xcelium> run
OK: 0 tests
Simulation complete via $finish(1) at time 717 NS + 0
```). Questa situazione sembra dovuta alla mancanza di connessione interna al `device`, ma non l'ho ancora approfondita in quanto preferirei seguire il flusso originale se possibile.




