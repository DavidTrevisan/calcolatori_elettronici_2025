= Progetto 3: Multiplier and Count Leading Zeroes

Questa sezione analizza il dispositivo d'esempio chiamato semplicemente `device`.
Il componente é rappresentato dalle seguenti porte di input/output.

[table_device_IOports,subs="attributes+"]
[cols="^2m,^2,6",options="header"]
|===

|Signal
|Direction
|Description

|start
|IN
|Inizia una nuova operazione con gli operandi presentati.

|op
|IN
|Seleziona quale operazione effettuare sugli ingressi.

`@0`: Moltiplicazione di `A` per `B`.

`@1`: _Count leading zeroes_ (*CLZ*) di `A`.

|A
|IN
|Primo operando per la moltiplicazione.

Operando dove eseguire *CLZ*.

|B
|IN
|Secondo operando per la moltiplicazione.

|done
|OUT
|Segnale di `valid` di `RES`.
Indica che il risultato in uscita al dispositivo puó essere valutato.

|RES
|OUT
|Risultato dell'elaborazione dipendente da `op`.

|===

[.center,svgbob-device_ports]
[svgbob]
----
                +----------------+
    A[n] ------>|                |
    B[n] ------>|                |----> RES [2n]
                |                |
                |     device     |
   start ------>|                |----> done
      op ------>|                |
                |                |
                +----------------+
----

Il comportamento della CTRL-Unit del dispositivo viene descritto insieme al datapath nello stesso file `device.vhdl`.
Il flusso é rappresentato nel seguente ASM-Chart:

.`device` ASM-Chart CTRL-Unit
[#fig_device_ctrl,reftext='{figure-caption} {counter:refnum}']
image::images/ASM-device_ctrl.drawio.svg[]

Risulta disponibile un'infrastruttura di test composta da `testbench` che istanzia i generatori di reset e clock, ed il dispositivo `device` collegato ad un generatore di stimoli, `tester`.
Il flusso di test implementato é riassunto come segue:

. Testa diversi operandi.
.. Testa entrambe le operazioni.
. Verifica il risultato proposto confrontandolo con il risultato in software.
. Al termine della sequenza stampa un messaggio relativo al successo o meno del test.

Opzionalmente si puó definire il generic `VERBOSE` per stampare su `stdout` più informazioni sugli eventuali risultati errati.

Il testbench espone alcuni `generics` a _top-level_.
Quelli più rilevanti per le simulazioni sono:

. `NBITS`: Definisce la dimensione degli operandi `A` e `B`.
. `VERBOSE`: Abilita il comportamento del `tester` descritto sopra.
. `NTESTS`: Definisce il numero di test and diagrams da effettuare per ogni operazione.

##TODO: Add some expectations and diagrams on the critical paths##
== RTL Simulations

Sempre con l'aiuto dello script `runSim_ghdl` sono state effettuate simulazioni RTL con i seguenti parametri:

. `NBITS`: {16, 32, 64}
. `NTESTS`: 10000

Per le relative esecuzioni sono presenti dei report nella cartella `simul.rtl`, contenenti anche i comandi generati dallo script.

[source, bash]
----
projects/03_multiplier_and_clz/simul.rtl/report_rtl_NTESTS_10000_NBITS_16.txt
projects/03_multiplier_and_clz/simul.rtl/report_rtl_NTESTS_10000_NBITS_32.txt
projects/03_multiplier_and_clz/simul.rtl/report_rtl_NTESTS_10000_NBITS_64.txt
----

[#device_xcelium_rtl_scripts]
Per questo progetto é stato anche utilizzato il simulatore _Xcelium_, e sono stati predisposti alcuni semplici script per automatizzarne il flusso.

Il primo script, `scripts/rtl_xcelium` effettua le seguenti operazioni:

. Porta la directory di lavoro in `simul.rtl`.
. Analizza i file VHDL (standard VHDL-1993) indicati nel file `sources.vc`.
. Elabora la top level entity `testbench`
.. In questo punto sono utilizzati i generics `NBITS => 32` e `NTESTS => 10000`.
.. Sono anche aggiunte le opzioni per la coverage del DUT.
. Esegue la simulazione del top level `testbench`.

Per l'esecuzione della simulazione viene utilizzato il secondo script, `scripts/xsim.tcl`, che raccoglie i semplici comandi TCL per lo strumento:

. Crea i database per le tracce dei segnali:
.. VCD (waveform standard)
.. TRN (xcelium specific)
. Crea il file SAIF contentente la _switching activity_ del DUT.
. Lancia la simulazione con il comando `run`.
. Chiude i database per il salvataggio.
. Esce dal tool.

I file VCD cosí generati sono visualizzabili con qualsiasi analizzatore di forme d'onda (come _GTKWave_), mentre i file TRN sono da utilizzarsi con la versione specifica per Xcelium, _Simvision_.

Un'analisi dei log e dei segnali generati dai due simulatori (GHDL e Xcelium) non evidenzia difformitá, e si suppone che la descrizione in VHDL del dispositivo sia funzionalmente robusta per passare alla fase di sintesi.

== Stdcells synthesis and evaluations

Per la sintesi di `device`, é stato utilizzato il tool `Genus Synthesis`, con la libreria _stdcells_ di `nangate`.
Il flusso é raccolto negli script `synth_genus` e `genus.tcl`.

Per utilizzare gli script forniti, si assume che la libreria in questione sia disponibile in un percorso chiamato `libs`.
Per ottenerlo é possibile creare nella root dei progetti un _symlink_ verso la libreria reale.
Alternativamente risulta necessario aggiustare il percorso indicato nello script.

=== Synthesis Setup

The synthesis flow target the following:

*Tool*::
- Cadence Genus(TM) Synthesis Solution, Version: 19.14-s108_1
*Stdcell*::
- Nangate stdcells v2011.01-HR04-2011-01-19
- Nominal voltage: 1.10V
- (Likely) Technology Node: 45nm
*Constraints*::
- Clock: 1GHz (1ns period) - 5% Jitter
- Output capacitance: 0.484 pF
- Input delay/Setup Time: 0.4ns (40% clock period)
- Output delay/C2O Time: 0.4ns (40% clock period)
*Device configuration*::
- `NBITS`: 32

The chosen driving cell has been selected as an average candidate between the buffers available in `stdcells.lib`.
The module is called `BUF_X8`, intermediate between `BUF_X1` and `BUF_X32`, and the script sets it with the command:

[source, tcl]
----
set_driving_cell -cell BUF_X8 $allin
----

followed immediately after with the average output capacitance set to the scaled value (Genus uses `fF` while the library uses `pF`) taken from the field `BUF_X8.pin (Z).max_capacitance`:

[source, tcl]
----
set_load 0.484009 $allout
----

The resulting metrics are collected in the reports saved under `synth/output`, or can be generated again via the synthesis scripts, and the key figures are collected in the following table:

[table_device_synth,subs="attributes+"]
[cols="^1m,^2,^2,^2",options="header"]
|===
|
| Area (µm²)
| Worst Slack (ns)
| Cell count

| Std
| 2112.572
| 1
| 1336

| Opt
| 2103.794
| 1
| 1323

|===

[NOTE]
====
The script does not generate the optimized results by default.

In order to add them, the lines delimited by `## ENABLE SYN_OPT` must be uncommented and the `genus.tcl` script rerun.
====

The `report_timing` returns a warning (`Warning : Timing problems have been detected in this design. [TIM-11]`) due to unconstrained nets.
Through the command `check_timing_intent` it is visible that the mentioned net is the `rst_n` signal, which doesn't have a driver.

[source,tcl]
----
-------------------------------------------------------------------------------
Inputs without external driver/transition

The following primary inputs have no external driver or input transition set.
As a result the transition on the ports will be assumed as zero. The
'external_driver' attribute is used to add and external driver or the
'fixed_slew' attribute to add an external transition.

port:device/rst_n
-------------------------------------------------------------------------------
----

The warning is expected and can be waived as it is assumed that the `rst_n` signal is driven by an external _ideal_ synchronizer, as directed by the following tool's `tcl` commands:

[%unbreakable]
[source, tcl]
----
# rst_n constraints
# rst_n not ideal net
remove_ideal_network $reset_name
# rst_n can use 90% clk cycle to reach all FFs
path_delay -delay [expr 0.9 * $clock_time * 1000] -name reset_delay -from $reset_name
# assume rst_n as driven by a synchronizer
set_input_delay 0 $reset_name -clock mainclk
# assume rst_n with ideal drive
set_drive 0 $reset_name
----

Given that the resulting slack is minimal (1ns in both standard and optimized synthesis), the tool doesn't accept adding clock gating, as all present flops are timing critical.
With the RTL Simulation generated `.saif` file power estimations, it seems acceptable to keep the design without clock gating circuitry.

.device power estimation on RTL switching activity
[%unbreakable]
[source,ascii]
----
Info    : Joules engine is used. [RPT-16]
        : Joules engine is being used for the command report_power.
Instance: /device
Power Unit: W
PDB Frames: /stim#0/frame#0
  -------------------------------------------------------------------------
    Category         Leakage     Internal    Switching        Total    Row%
  -------------------------------------------------------------------------
      memory     0.00000e+00  0.00000e+00  0.00000e+00  0.00000e+00   0.00%
    register     1.42434e-05  1.11006e-03  1.86579e-04  1.31088e-03  48.27%
       latch     0.00000e+00  0.00000e+00  0.00000e+00  0.00000e+00   0.00%
       logic     3.01213e-05  5.94002e-04  5.94608e-04  1.21873e-03  44.88%
        bbox     0.00000e+00  0.00000e+00  0.00000e+00  0.00000e+00   0.00%
       clock     0.00000e+00  0.00000e+00  1.86219e-04  1.86219e-04   6.86%
         pad     0.00000e+00  0.00000e+00  0.00000e+00  0.00000e+00   0.00%
          pm     0.00000e+00  0.00000e+00  0.00000e+00  0.00000e+00   0.00%
  -------------------------------------------------------------------------
    Subtotal     4.43647e-05  1.70406e-03  9.67406e-04  2.71583e-03 100.01%
  Percentage           1.63%       62.75%       35.62%      100.00% 100.00%
  -------------------------------------------------------------------------
----

It is possible to see how the library in use seems to be well optimized against leakage currents, which represent less than 2% of the total power.
More power considerations will be given after the gate-level simulation and the updated switching activity.

== Gate-level simulations

##TODO: Some and trials changing the clk period?###
##TODO: Break functionality over slack time?###

== Other evaluations
