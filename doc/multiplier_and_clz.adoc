= Progetto 3: Multiplier and Count Leading Zeroes

Questa sezione analizza il dispositivo d'esempio chiamato semplicemente `device`.
Il componente é rappresentato dalle seguenti porte di input/output.

[table_device_IOports,subs="attributes+"]
[cols="^2m,^2,6",options="header"]
|===

|Signal
|Direction
|Description

|start
|IN
|Inizia una nuova operazione con gli operandi presentati.

|op
|IN
|Seleziona quale operazione effettuare sugli ingressi.

`@0`: Moltiplicazione di `A` per `B`.

`@1`: _Count leading zeroes_ (*CLZ*) di `A`.

|A
|IN
|Primo operando per la moltiplicazione.

Operando dove eseguire *CLZ*.

|B
|IN
|Secondo operando per la moltiplicazione.

|done
|OUT
|Segnale di `valid` di `RES`.
Indica che il risultato in uscita al dispositivo puó essere valutato.

|RES
|OUT
|Risultato dell'elaborazione dipendente da `op`.

|===

[.center,svgbob-device_ports]
[svgbob]
----
                +----------------+
    A[n] ------>|                |
    B[n] ------>|                |----> RES [2n]
                |                |
                |     device     |
   start ------>|                |----> done
      op ------>|                |
                |                |
                +----------------+
----

Il comportamento della CTRL-Unit del dispositivo viene descritto insieme al datapath nello stesso file `device.vhdl`.
Il flusso é rappresentato nel seguente ASM-Chart:

.`device` ASM-Chart CTRL-Unit
[#fig_device_ctrl,reftext='{figure-caption} {counter:refnum}']
image::images/ASM-device_ctrl.drawio.svg[]

Risulta disponibile un'infrastruttura di test composta da `testbench` che istanzia i generatori di reset e clock, ed il dispositivo `device` collegato ad un generatore di stimoli, `tester`.
Il flusso di test implementato é riassunto come segue:

. Testa diversi operandi.
.. Testa entrambe le operazioni.
. Verifica il risultato proposto confrontandolo con il risultato in software.
. Al termine della sequenza stampa un messaggio relativo al successo o meno del test.

Opzionalmente si puó definire il generic `VERBOSE` per stampare su `stdout` più informazioni sugli eventuali risultati errati.

Il testbench espone alcuni `generics` a _top-level_.
Quelli più rilevanti per le simulazioni sono:

. `NBITS`: Definisce la dimensione degli operandi `A` e `B`.
. `VERBOSE`: Abilita il comportamento del `tester` descritto sopra.
. `NTESTS`: Definisce il numero di test da effettuare per ogni operazione.

== RTL Simulations

Sempre con l'aiuto dello script `runSim_ghdl` sono state effettuate simulazioni RTL con i seguenti parametri:

. `NBITS`: {16, 32, 64}
. `NTESTS`: 10000

Per le relative esecuzioni sono presenti dei report nella cartella `simul.rtl`, contenenti anche i comandi generati dallo script.

[source, bash]
----
projects/03_multiplier_and_clz/simul.rtl/report_rtl_NTESTS_10000_NBITS_16.txt
projects/03_multiplier_and_clz/simul.rtl/report_rtl_NTESTS_10000_NBITS_32.txt
projects/03_multiplier_and_clz/simul.rtl/report_rtl_NTESTS_10000_NBITS_64.txt
----

[#device_xcelium_rtl_scripts]
Per questo progetto é stato anche utilizzato il simulatore _Xcelium_, e sono stati predisposti alcuni semplici script per automatizzarne il flusso.

Il primo script, `scripts/ae_xcelium` effettua le seguenti operazioni:

. Porta la directory di lavoro in `simul.rtl`.
. Analizza i file VHDL (standard VHDL-1993) indicati nel file `sources.vc`.
. Elabora la top level entity `testbench`
.. In questo punto sono utilizzati i generics `NBITS => 32` e `NTESTS => 10000`.
.. Sono anche aggiunte le opzioni per la coverage del DUT.
. Esegue la simulazione del top level `testbench`.

Per l'esecuzione della simulazione viene utilizzato il secondo script, `scripts/xsim.tcl`, che raccoglie i semplici comandi TCL per lo strumento:

. Crea i database per le tracce dei segnali:
.. VCD (waveform standard)
.. TRN (xcelium specific)
. Crea il file SAIF contentente la _switching activity_ del DUT.
. Lancia la simulazione con il comando `run`.
. Chiude i database per il salvataggio.
. Esce dal tool.

I file VCD cosí generati sono visualizzabili con qualsiasi analizzatore di forme d'onda (come _GTKWave_), mentre i file TRN sono da utilizzarsi con la versione specifica per Xcelium, _Simvision_.

Un'analisi dei log e dei segnali generati dai due simulatori (GHDL e Xcelium) non evidenzia difformitá, e si suppone che la descrizione in VHDL del dispositivo sia funzionalmente robusta per passare alla fase di sintesi.

== Stdcells synthesis and evaluations

Per la sintesi di `device`, si é utilizzato il tool `Genus`, con un flusso raccolto nuovamente in alcuni script, utilizzando la libreria _stdcells_ di `nangate`.

Per utilizzare gli script forniti, si assume che la libreria in questione sia disponibile in un percorso chiamato `libs`.
Per ottenerlo é possibile creare nella root dei progetti un _symlink_ verso la libreria reale.
Alternativamente sará necessario aggiustare il percorso indicato nello script.



== Gate-level simulations
== Other evaluations
